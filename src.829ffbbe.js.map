{"version":3,"sources":["../../src/config/theme.ts","../../src/shapes/Circle.ts","../../src/utils/getRandomColor.ts","../../src/tree/BinaryTreeNode.ts","../../src/tree/BinarySearchTreeNode.ts","../../src/tree/index.ts","../../src/utils/getRGBString.ts","../../src/helpers/ColorGenerator.ts","../../src/canvas/Canvas.ts","../../src/enumns/VisualizationType.ts","../../src/utils/tree.ts","../../src/strokes/BezierCurve.ts","../../src/utils/connectPointsWithBezierCurve.ts","../../src/canvas/drawPrettyBinaryTree.ts","../../src/canvas/drawExpandableBinaryTree.ts","../../src/canvas/drawSimpleBinaryTree.ts","../../src/canvas/drawBinaryTree.ts","../../src/canvas/index.ts","../../src/enumns/index.ts","../../src/config/index.ts","../src/index.ts","src/index.ts"],"names":[],"mappings":"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","file":"src.829ffbbe.js","sourceRoot":"..","sourcesContent":["import {Theme} from './types';\n\nconst theme: Theme = {\n  radius: 20,\n  growthAndShrinkTimes: 1.25,\n  leafNodeSpace: 75,\n  lineHeight: 90,\n  fontSize: 10,\n  textFont: 'Poppins',\n  strokeColor: '#f56042',\n  colorArray: [\n    {bgColor: '#fff2e0', borderColor: '#f56042'},\n  ],\n};\n\n/**\n * Set the user defined theme if required\n *\n * @param {Theme} userDefinedTheme\n */\nexport function setTheme(userDefinedTheme: Partial<Theme>) {\n  const {\n    radius = theme.radius,\n    growthAndShrinkTimes = theme.growthAndShrinkTimes,\n    leafNodeSpace = theme.leafNodeSpace,\n    lineHeight = theme.lineHeight,\n    colorArray = theme.colorArray,\n    textFont = theme.textFont,\n    strokeColor = theme.strokeColor,\n    fontSize = theme.fontSize,\n  } = userDefinedTheme;\n\n  theme.radius = radius;\n  theme.growthAndShrinkTimes = growthAndShrinkTimes;\n  theme.leafNodeSpace = leafNodeSpace;\n  theme.lineHeight = lineHeight;\n  theme.colorArray = colorArray;\n  theme.textFont = textFont;\n  theme.strokeColor = strokeColor;\n  theme.fontSize = fontSize;\n}\n\nexport default theme;\n\n","import {CanvasComponent} from '..';\nimport theme from '../config/theme';\nimport {CircleColorSettings} from '../config/types';\nimport {RadiusSettings} from './types';\n\n/**\n * Rate at which circle will grow or shrink\n */\nconst growthRate = 0.3;\n\n/**\n * Describes a circle in the canvas\n */\nclass Circle {\n  /**\n   * Radius of the circle\n   */\n  private radiusSettings: RadiusSettings\n\n  /**\n   * The colorId of the circle\n   */\n  private colorId: string = ''\n\n  /**\n   * Color of the circle\n   */\n  private colorSettings: CircleColorSettings\n\n  /**\n   * Value to be displayed inside the circle\n   */\n  private value: string\n\n  /**\n   * X Position of the circle\n   */\n  private x: number = -1\n\n  /**\n   * Y Position of the circle\n   */\n  private y: number = -1\n\n  /**\n   * For constructing a new circle\n   *\n   * @param {string} value\n   * @param {number} radius\n   * @param {CircleColorSettings} colorSettings\n   */\n  constructor(\n      value: string,\n      radius: number,\n      colorSettings: CircleColorSettings,\n  ) {\n    this.value = value;\n    this.colorSettings = colorSettings;\n    this.radiusSettings = {\n      currentRadius: radius,\n      originalRadius: radius,\n      maxRadius: radius * theme.growthAndShrinkTimes,\n      minRadius: radius / theme.growthAndShrinkTimes,\n    };\n  }\n\n  /**\n   * Draw the circle\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {number} radius\n   * @param {string} color\n   */\n  private drawCircle(\n      ctx: CanvasRenderingContext2D,\n      radius: number,\n      color: string,\n  ) {\n    const {x, y} = this;\n\n    ctx.beginPath();\n    ctx.fillStyle = color;\n    ctx.arc(x, y, radius, 0, Math.PI * 2, false);\n    ctx.fill();\n  }\n\n  /**\n   * Draw the border\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   */\n  private drawBorder(ctx: CanvasRenderingContext2D) {\n    const {x, y, colorSettings, radiusSettings: {currentRadius: radius}} = this;\n    const {borderColor} = colorSettings;\n\n    ctx.arc(x, y, radius, 0, Math.PI * 2, false);\n    ctx.strokeStyle = borderColor;\n    ctx.stroke();\n  }\n\n  /**\n   * Write the text\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   */\n  private writeText(ctx: CanvasRenderingContext2D) {\n    const {x, y, value, colorSettings} = this;\n    const {borderColor} = colorSettings;\n\n    // Decide font size\n    const fontSize = `${theme.fontSize}pt`;\n    const ySpacing = theme.fontSize/2;\n\n    ctx.fillStyle = borderColor;\n    ctx.font = `${fontSize} ${theme.textFont}`;\n    ctx.textAlign = 'center';\n    ctx.fillText(value, x, y + ySpacing);\n  }\n\n  /**\n   * Get the current radius\n   *\n   * @return {number}\n   */\n  getRadius() {\n    const {\n      radiusSettings: {currentRadius: radius},\n    } = this;\n    return radius;\n  }\n\n  /**\n   * Increase radius of the circle\n   * @param {number} maxRadius\n   * @return {boolean} - Weather size was changed\n   */\n  grow(maxRadius = this.radiusSettings.maxRadius) {\n    const {\n      radiusSettings: {\n        currentRadius,\n      },\n    } = this;\n\n    if (currentRadius < maxRadius) {\n      const originalIncreasedRadius = currentRadius + growthRate;\n      this.radiusSettings.currentRadius = originalIncreasedRadius > maxRadius ?\n      maxRadius : originalIncreasedRadius;\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Decrease the radius of the circle\n   * @param {number} minRadius\n   * @return {boolean} - Weather size was changed\n   */\n  shrink(minRadius = this.radiusSettings.minRadius) {\n    const {\n      radiusSettings: {\n        currentRadius,\n      },\n    } = this;\n\n    if (currentRadius > minRadius) {\n      const originalDecreasedRadius = currentRadius - growthRate;\n      this.radiusSettings.currentRadius = originalDecreasedRadius < minRadius ?\n      minRadius : originalDecreasedRadius;\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Bring the circle back to its original radius\n   * @return {boolean} - Weather size was changed\n   */\n  restoreCircle() {\n    const {\n      radiusSettings: {\n        currentRadius,\n        originalRadius,\n      },\n    } = this;\n\n    if (currentRadius > originalRadius) {\n      return this.shrink(originalRadius);\n    }\n\n    if (currentRadius < originalRadius) {\n      return this.grow(originalRadius);\n    }\n\n    return false;\n  }\n\n  /**\n   * Set the color id of the circle\n   *\n   * @param {string} colorId\n   */\n  setColorId(colorId: string) {\n    this.colorId = colorId;\n  }\n\n  /**\n   * Set the x and y coordinates of the circle\n   *\n   * @param {number} x\n   * @param {number} y\n   */\n  setCoordinates(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n\n  /**\n   * Draw the circle on the screen\n   * Draw the border\n   * Add the text\n   *\n   * @param {CanvasComponent} comp\n   * @return {string} - The color id represented by the unique color\n   */\n  draw(comp: CanvasComponent) {\n    const {\n      radiusSettings: {currentRadius: radius},\n      colorSettings: {bgColor},\n    } = this;\n\n    // Draw circle\n    this.colorId = this.colorId ? this.colorId : comp.getNextColor();\n    this.drawCircle(\n        comp.getContext(),\n        radius,\n        bgColor,\n    );\n    this.drawCircle(\n        comp.getHitContext(),\n        radius,\n        this.colorId,\n    );\n\n    // Draw border\n    this.drawBorder(comp.getContext());\n\n    // Write text\n    this.writeText(comp.getContext());\n\n    // Return the colorId\n    return this.colorId;\n  }\n}\n\nexport default Circle;\n","import {CircleColorSettings} from '../config/types';\nimport theme from '../config/theme';\n\n/**\n * Get a random color settings\n *\n * @return {CircleColorSettings}\n */\nfunction getRandomColor():CircleColorSettings {\n  const {colorArray} = theme;\n  return colorArray[Math.floor(Math.random() * colorArray.length)];\n}\n\nexport default getRandomColor;\n","import Circle from '../shapes/Circle';\nimport theme from '../config/theme';\nimport getRandomColor from '../utils/getRandomColor';\n\n/**\n * Describes a node of a binary tree\n */\nclass BinaryTreeNode<T extends string | number> {\n  /**\n   * The value of the node\n   */\n  value: T\n\n  /**\n   * The canvas circle\n   */\n  nodeCircle: Circle\n\n  /**\n   * The left child of the node\n   */\n  left?: BinaryTreeNode<T>\n\n  /**\n   * The right child of the node\n   */\n  right?: BinaryTreeNode<T>\n\n  /**\n   * For constructing a new binary tree node\n   *\n   * @param {T} value\n   */\n  constructor(value: T) {\n    this.value = value;\n    this.nodeCircle = new Circle(\n        `${value}`,\n        theme.radius,\n        getRandomColor(),\n    );\n  }\n\n  /**\n   * Set the left child\n   *\n   * @param {BinaryTreeNode} value\n   */\n  setLeft(value: BinaryTreeNode<T>) {\n    this.left = value;\n  }\n\n  /**\n   * Set the right child\n   *\n   * @param {BinaryTreeNode} value\n   */\n  setRight(value: BinaryTreeNode<T>) {\n    this.right = value;\n  }\n\n  /**\n   * Get the height of the binry tree from the node\n   * Height of root is 1\n   *\n   * @return {number}\n   */\n  getHeight():number {\n    const leftHeight = this.left?.getHeight() || 0;\n    const rightHeight = this.right?.getHeight() || 0;\n    return Math.max(leftHeight, rightHeight) + 1;\n  }\n}\n\nexport default BinaryTreeNode;\n","import BinaryTreeNode from './BinaryTreeNode';\n\n/**\n * A Binary search tree node\n */\nclass BinarySearchTreeNode<T extends string | number>\n  extends BinaryTreeNode<T> {\n    /**\n     * Left child of the node\n     */\n    left?: BinarySearchTreeNode<T>\n\n    /**\n     * Right child of the node\n     */\n    right?: BinarySearchTreeNode<T>\n\n    /**\n     * Set the left child of the node\n     *\n     * @param {BinarySearchTreeNode<T>} value\n     */\n    setLeft(value: BinarySearchTreeNode<T>) {\n      super.setLeft(value);\n    }\n\n    /**\n     * Set the right child of the node\n     *\n     * @param {BinarySearchTreeNode<T>} value\n     */\n    setRight(value: BinarySearchTreeNode<T>) {\n      super.setRight(value);\n    }\n\n    /**\n     * Insert a value into the node\n     * (Using Recursion)\n     *\n     * @param {T} value\n     */\n    insert(value: T) {\n      // Skip equal value\n      if (value === this.value) {\n        return;\n      }\n\n      // When value is lesser\n      if (value < this.value) {\n        if (this.left) {\n          this.left.insert(value);\n          return;\n        }\n        this.setLeft(new BinarySearchTreeNode(value));\n        return;\n      }\n\n      // When value is greater\n      if (this.right) {\n        this.right.insert(value);\n        return;\n      }\n      this.setRight(new BinarySearchTreeNode(value));\n    }\n\n    /**\n     * Find the minimum value from the given node\n     *\n     * @param {BinarySearchTreeNode<T>} node\n     * @return {BinarySearchTreeNode<T>}\n     */\n    findMinimum():BinarySearchTreeNode<T> {\n      if (this.left) {\n        return this.left.findMinimum();\n      }\n      return this;\n    }\n\n    /**\n     * Delete this node\n     *\n     * @param {BinarySearchTreeNode<T>} parent\n     * @return {[\n     *  BinarySearchTreeNode<T>,\n     *  BinarySearchTreeNode<T>\n     * ]} [deletedNode, currentRoot]\n     */\n    deleteThisNode(\n        parent?: BinarySearchTreeNode<T>,\n    ): [BinarySearchTreeNode<T>?, BinarySearchTreeNode<T>?] {\n      // Which direction is this node from the parent\n      const childDirection = parent?.left === this ? 'left' : 'right';\n\n      // Case 1: Delete leaf node\n      if (!this.left && !this.right) {\n        if (parent) {\n          delete parent[childDirection];\n        }\n        return [this];\n      }\n\n      // Case 2: Delete when there is only one child\n      if (this.left && !this.right) {\n        if (parent) {\n          parent[childDirection] = this.left;\n        }\n        return [this, this.left];\n      } else if (this.right && !this.left) {\n        if (parent) {\n          parent[childDirection] = this.right;\n        }\n        return [this, this.right];\n      }\n\n      // Case 3: There are 2 children\n\n      // Step 1: Delete the in order successor\n      const [deletedNode] = this.right!.delete(\n        this.right!.findMinimum().value, this,\n      );\n\n      // Step 2: Set the in order successor as the current node\n      // Deleted node will always be found\n      deletedNode!.left = this.left;\n      deletedNode!.right = this.right;\n      if (parent) {\n        parent[childDirection] = deletedNode;\n      }\n\n      return [this, deletedNode];\n    }\n\n    /**\n     * Delete a node\n     * (Using recursion)\n     *\n     * @param {T} value\n     * @param {BinarySearchTreeNode<T>} parent\n     * @return {[\n     *  BinarySearchTreeNode<T>,\n     *  BinarySearchTreeNode<T>\n     * ]} [deletedNode, currentRoot]\n     */\n    delete(\n        value: T,\n        parent?: BinarySearchTreeNode<T>,\n    ): [BinarySearchTreeNode<T>?, BinarySearchTreeNode<T>?] {\n      // Delete from left node\n      if (value < this.value && this.left) {\n        const [deletedNode] = this.left.delete(value, this);\n        return [deletedNode, this];\n      }\n\n      // Delete from right node\n      if (value > this.value && this.right) {\n        const [deletedNode] = this.right.delete(value, this);\n        return [deletedNode, this];\n      }\n\n      // Delete the current node\n      if (this.value === value) {\n        const res = this.deleteThisNode(parent);\n        delete this.left;\n        delete this.right;\n        return res;\n      }\n\n      return [, this];\n    }\n}\n\nexport default BinarySearchTreeNode;\n","import BinaryTreeNode from './BinaryTreeNode';\nimport BinarySearchTreeNode from './BinarySearchTreeNode';\n\nexport {\n  BinaryTreeNode,\n  BinarySearchTreeNode,\n};\n","/**\n * Get RGB string from red green and blue values\n *\n * @param {number} red\n * @param {number} green\n * @param {number} blue\n * @return {string}\n */\nfunction getRGBString(red: number, green: number, blue: number) {\n  return `rgb(${red}, ${green}, ${blue})`;\n}\n\nexport default getRGBString;\n","import getRGBString from '../utils/getRGBString';\n\n/**\n * The gap between 2 ids\n */\nconst gap = 10;\n\n/**\n * For generating color\n */\nclass ColorGenerator {\n  /**\n   * The red color value\n   */\n  private red = 0\n\n  /**\n   * The green color value\n   */\n  private green = 0\n\n  /**\n   * The blue color value\n   */\n  private blue = 1\n\n  /**\n   * Increment a color\n   *\n   * @param {'red' | 'green' | 'blue'} color\n   */\n  incrementColor(color: 'red' | 'green' | 'blue') {\n    this[color] = (this[color] + gap) % 256;\n  }\n\n  /**\n   * Get the next color\n   * Starts from rgb(0, 0, 0)\n   *\n   * @return {string}\n   */\n  getNextColor() {\n    // Generate the rgb value\n    const color = getRGBString(this.red, this.green, this.blue);\n\n    // Increment the color\n    this.incrementColor('blue');\n    if (this.blue < gap) {\n      this.incrementColor('green');\n      if (this.green < gap) {\n        this.incrementColor('red');\n      }\n    }\n\n    // Return the color\n    return color;\n  }\n}\n\nexport default ColorGenerator;\n","import ColorGenerator from '../helpers/ColorGenerator';\nimport getRGBString from '../utils/getRGBString';\nimport {GetColorCallBack} from './types';\n\n/**\n * Defines one canvas\n */\nclass CanvasComponent {\n  /**\n   * The canvas element\n   */\n  private $el: HTMLCanvasElement\n\n  /**\n   * This is a hidden canvas element\n   * which is used to redraw all the elements from the canvas\n   * in unique colors.\n   *\n   * This way an element can be easily identified from this hit canvas\n   * just by using the color in O(1)\n   *\n   * Otherwise to identify an element in the canvas it will take O(n)\n   *\n   */\n  private $hitEl: HTMLCanvasElement\n\n  /**\n   * The color generator for generating new color\n   */\n  private colorGenerator: ColorGenerator\n\n  /**\n   * The current hovering color\n   */\n  private currentHoveringColor: string = ''\n\n  /**\n   * For storing the on hover callback\n   */\n  private onHoverCB?: (event: MouseEvent) => void\n\n  /**\n   * For storing the on click callback\n   */\n  private onClickCB?: (event: MouseEvent) => void\n\n  /**\n   * For constructing a new canvas component\n   *\n   * @param {HTMLCanvasElement} $el\n   */\n  constructor($el: HTMLCanvasElement) {\n    const $hitEl = document.createElement('canvas');\n\n    this.$el = $el;\n    this.$hitEl = $hitEl;\n    this.colorGenerator = new ColorGenerator();\n  }\n\n  /**\n   * Clears the canvas\n   */\n  clearCanvas() {\n    const {height, width} = this.$el;\n    this.getContext().clearRect(0, 0, width, height);\n  }\n\n  /**\n   * Set the maximum width and height\n   *\n   * @param {number} height\n   * @param {number} width\n   */\n  setMaxWidthAndHeight(height: number, width: number) {\n    this.$hitEl.height = this.$el.height = height;\n    this.$hitEl.width = this.$el.width = width;\n  }\n\n  /**\n   * Get the hit 2d context\n   *\n   * @return {CanvasComponent}\n   */\n  getHitContext(): CanvasRenderingContext2D {\n    const ctx = this.$hitEl.getContext('2d');\n    if (!ctx) {\n      throw new Error('Cannot get 2d context');\n    }\n\n    return ctx;\n  }\n\n  /**\n   * Get the 2d context\n   *\n   * @return {CanvasRenderingContext2D}\n   */\n  getContext(): CanvasRenderingContext2D {\n    const ctx = this.$el.getContext('2d');\n    if (!ctx) {\n      throw new Error('Cannot get 2d context');\n    }\n\n    return ctx;\n  }\n\n  /**\n   * Get the next color from the color generator\n   *\n   * @return {string}\n   */\n  getNextColor() {\n    return this.colorGenerator.getNextColor();\n  }\n\n  /**\n   * On hover get the canvas hit color\n   *\n   * @param {GetColorCallBack} cb\n   */\n  onHover(cb: GetColorCallBack) {\n    // Clear previous listeners\n    if (this.onHoverCB) {\n      this.$el.removeEventListener('mousemove', this.onHoverCB);\n    }\n\n    // Set the callback\n    this.onHoverCB = (event: MouseEvent) => {\n      const {pageX, pageY} = event;\n      const {data: pixel} = this.getHitContext().getImageData(\n          pageX - this.$el.offsetLeft,\n          pageY - this.$el.offsetTop,\n          1, 1,\n      );\n\n      // Callback should only be called on color change\n      const color = getRGBString(pixel[0], pixel[1], pixel[2]);\n      if (this.currentHoveringColor !== color) {\n        this.currentHoveringColor = color;\n        cb(color);\n      }\n    };\n\n    // Add the event listener\n    this.$el.addEventListener('mousemove', this.onHoverCB);\n  }\n\n  /**\n   * On click of canvas get the hit color\n   *\n   * @param {GetColorCallBack} cb\n   */\n  onClick(cb: GetColorCallBack) {\n    // Clear previous listeners\n    if (this.onClickCB) {\n      this.$el.removeEventListener('click', this.onClickCB);\n    }\n\n    // Set the callback\n    this.onClickCB = (event: MouseEvent) => {\n      const {pageX, pageY} = event;\n      console.log(pageX, pageY);\n      const {data: pixel} = this.getHitContext().getImageData(\n          pageX - this.$el.offsetLeft,\n          pageY - this.$el.offsetTop,\n          1, 1,\n      );\n      cb(getRGBString(pixel[0], pixel[1], pixel[2]));\n    };\n\n    // Add the event listener\n    this.$el.addEventListener('click', this.onClickCB);\n  }\n}\n\nexport default CanvasComponent;\n\n\n","export enum VisualizationType {\n  SIMPLE,\n  PRETTY,\n  EXPANDABLE,\n  HIGHLIGHT\n}\n","import theme from '../config/theme';\n\n/**\n * Get the max number of leaf nodes from height of the binary tree\n *\n * @param {number} treeHeight - Height of the tree (number of nodes from)\n * @return {number} - Maximum number of leaf nodes\n */\nexport function getMaxLeafNodesFromHeight(treeHeight: number) {\n  return 2 ** (treeHeight-1);\n}\n\n/**\n * Maximum canvas width required from number of tree nodes\n *\n * @param {number} maxNodes - Maximum number of nodes\n * @return {number} - The max width required\n */\nexport function getCanvasWidthFromMaxNodeSpacing(maxNodes: number) {\n  return (maxNodes + 2) * theme.leafNodeSpace;\n}\n\n/**\n * Get the x position from given horizontal node position\n *\n * @param {number} nodes - The number of nodes from the left\n * @return {number} - The x position\n */\nexport function getXPositionFromGivenHorizontalNodePosition(nodes: number) {\n  return (nodes) * theme.leafNodeSpace;\n}\n\n/**\n * Get canvas height from the tree height\n *\n * @param {number} treeHeight - Height of the tree (number of nodes from)\n * @return {number} - The canvas height in px\n */\nexport function getCanvasHeightFromTreeHeight(treeHeight: number) {\n  return (treeHeight) * theme.lineHeight;\n}\n\n/**\n * Get required and actual height and width\n *\n * @param {number} maxNodeSpacing\n * @param {number} heightOfTree\n * @param {number} maxWidth\n * @param {number} maxHeight\n * @return {{\n *  maxCanvasHeightRequired: number,\n *  maxCanvasWidthRequired:number,\n *  actualMaxHeight: number,\n *  actualMaxWidth: number\n * }}\n */\nexport function getRequiredAndActualHeightAndWidth(\n    maxNodeSpacing: number,\n    heightOfTree: number,\n    maxWidth: number,\n    maxHeight: number,\n) {\n  const maxCanvasWidthRequired = getCanvasWidthFromMaxNodeSpacing(\n      maxNodeSpacing,\n  );\n  const maxCanvasHeightRequired = getCanvasHeightFromTreeHeight(heightOfTree+1);\n  const actualMaxWidth = maxCanvasWidthRequired > maxWidth ?\n    maxCanvasWidthRequired : maxWidth;\n  const actualMaxHeight = maxCanvasHeightRequired > maxHeight ?\n    maxCanvasHeightRequired : maxHeight;\n\n  return {\n    maxCanvasHeightRequired,\n    maxCanvasWidthRequired,\n    actualMaxHeight,\n    actualMaxWidth,\n  };\n}\n","import {Point} from '../types/Point';\n\n/**\n * Describes a bezier curve\n */\nclass BezierCurve {\n  /**\n   * X Configurations\n   */\n  xStart: number\n  cp1x: number\n  cp2x: number\n  xEnd: number\n\n  /**\n   * Y Configurations\n   */\n  yStart: number\n  cp1y: number\n  cp2y: number\n  yEnd: number\n\n  /**\n   * Color of the curve\n   */\n  color: string\n\n  /**\n   * Construct a new bezier curve\n   *\n   * @param {string} color\n   * @param {Point} start\n   * @param {Point} cp1\n   * @param {Point} cp2\n   * @param {Point} end\n   */\n  constructor(\n      color: string,\n      start: Point,\n      cp1: Point,\n      cp2: Point,\n      end: Point,\n  ) {\n    const {x: xStart, y: yStart} = start;\n    const {x: cp1x, y: cp1y} = cp1;\n    const {x: cp2x, y: cp2y} = cp2;\n    const {x: xEnd, y: yEnd} = end;\n\n    this.color = color;\n    this.xStart = xStart;\n    this.yStart = yStart;\n    this.cp1x = cp1x;\n    this.cp1y = cp1y;\n    this.cp2x = cp2x;\n    this.cp2y = cp2y;\n    this.xEnd = xEnd;\n    this.yEnd = yEnd;\n  }\n\n  /**\n   * Draw the bezier curve\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   */\n  draw(ctx: CanvasRenderingContext2D) {\n    ctx.beginPath();\n    ctx.moveTo(this.xStart, this.yStart);\n    ctx.strokeStyle = this.color;\n    ctx.bezierCurveTo(\n        this.cp1x,\n        this.cp1y,\n        this.cp2x,\n        this.cp2y,\n        this.xEnd,\n        this.yEnd,\n    );\n    ctx.stroke();\n  }\n}\n\n\nexport default BezierCurve;\n","import CanvasComponent from '../canvas/Canvas';\nimport theme from '../config/theme';\nimport BezierCurve from '../strokes/BezierCurve';\nimport {\n  HorizontalStartAndEndInput,\n  VerticalStartAndEndInput,\n} from '../canvas/types';\n\n/**\n * Connect two points with a bezier curve\n *\n * @param {CanvasComponent} canvasComponent\n * @param {HorizontalStartAndEndInput} horizontalConfig\n * @param {VerticalStartAndEndInput} verticalConfig\n */\nfunction connectPointsWithBezierCurve(\n    canvasComponent: CanvasComponent,\n    horizontalConfig: HorizontalStartAndEndInput,\n    verticalConfig: VerticalStartAndEndInput,\n) {\n// X, Y Calculation\n  const {xStart, xEnd} = horizontalConfig;\n  const {yStart, yEnd} = verticalConfig;\n  const halfY = (yStart + yEnd) / 2;\n  const halfX = (xStart + xEnd) / 2;\n\n  // Draw the bezier curve\n  const berzierCurve = new BezierCurve(\n      theme.strokeColor,\n      {x: xStart, y: yStart},\n      {x: halfX, y: halfY},\n      {x: xEnd, y: halfY},\n      {x: xEnd, y: yEnd},\n  );\n  berzierCurve.draw(canvasComponent.getContext());\n}\n\nexport default connectPointsWithBezierCurve;\n","import CanvasComponent from './Canvas';\nimport theme from '../config/theme';\nimport BinaryTreeNode from '../tree/BinaryTreeNode';\nimport {Point} from '../types/Point';\nimport {\n  getCanvasHeightFromTreeHeight,\n  getRequiredAndActualHeightAndWidth,\n  getXPositionFromGivenHorizontalNodePosition,\n} from '../utils/tree';\nimport connectPointsWithBezierCurve\n  from '../utils/connectPointsWithBezierCurve';\nimport {\n  IndividualInputOptions,\n  LeftAndRightSpacing,\n} from './types';\n\n/**\n * The current animation frame that is going on\n */\nlet animationFrameId: number;\n\n/**\n * Current color that is being hovered on\n */\nlet hoveredColorId: string;\n\n/**\n * Spacing map for storing space requirements\n */\nlet spacingMap: Map<BinaryTreeNode<string | number>, LeftAndRightSpacing>;\n\n/**\n * Clear the existing animation frame if any and request an animation frame\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} canvasComponent\n * @param {Point} position\n * @param {boolean} highlightMode\n */\nfunction requestAnimationFrame(\n    root: BinaryTreeNode<string | number>,\n    canvasComponent: CanvasComponent,\n    position: Point,\n    highlightMode: boolean,\n) {\n  // Clear existing animation frame\n  if (animationFrameId) {\n    cancelAnimationFrame(animationFrameId);\n  }\n\n  // Request a new one\n  animationFrameId = window.requestAnimationFrame(() => {\n    canvasComponent.clearCanvas();\n    const requiredRedraw = recursivelyDrawNodes(\n        root, canvasComponent, position, highlightMode);\n    if (requiredRedraw) {\n      requestAnimationFrame(root, canvasComponent, position, highlightMode);\n    }\n  });\n}\n\n/**\n * Draw single node\n *\n * @param {BinaryTreeNode} node\n * @param {CanvasComponent} comp\n * @param {Point} position\n * @param {boolean} highlightMode\n * @return {boolean} Weather redraw is required\n */\nfunction drawSingleNode(\n    node: BinaryTreeNode<string | number>,\n    comp: CanvasComponent,\n    position: Point,\n    highlightMode: boolean,\n) {\n  const {x, y} = position;\n  node.nodeCircle.setCoordinates(x, y);\n\n  // Grow or shrink while hover\n  const colorId = node.nodeCircle.draw(comp);\n  if (colorId === hoveredColorId && highlightMode) {\n    return node.nodeCircle.grow();\n  } else {\n    return node.nodeCircle.restoreCircle();\n  }\n}\n\n/**\n * Recursively draw all the nodes for a pretty tree\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} canvasComponent\n * @param {Point} position\n * @param {boolean} highlightMode\n * @return {boolean}\n */\nfunction recursivelyDrawNodes(\n    root: BinaryTreeNode<string | number>,\n    canvasComponent: CanvasComponent,\n    position: Point,\n    highlightMode: boolean,\n): boolean {\n  const {x: xPosition, y: yPosition} = position;\n\n  // Draw the node\n  let requiredRedraw = drawSingleNode(\n      root,\n      canvasComponent,\n      {x: xPosition, y: yPosition},\n      highlightMode,\n  );\n  root.nodeCircle.setCoordinates(xPosition, yPosition);\n  root.nodeCircle.draw(canvasComponent);\n\n  // Root spacings\n  const {left, right} = spacingMap.get(root)!;\n\n  // Draw the left child\n  if (root.left) {\n    const leftOfLeft = spacingMap.get(root.left)!.left;\n    const childYPosition = yPosition + theme.lineHeight;\n    const leftPosition = {\n      x: xPosition - getXPositionFromGivenHorizontalNodePosition(\n          left - leftOfLeft,\n      ),\n      y: childYPosition,\n    };\n\n    requiredRedraw = recursivelyDrawNodes(\n        root.left,\n        canvasComponent,\n        leftPosition,\n        highlightMode,\n    ) || requiredRedraw;\n    connectPointsWithBezierCurve(canvasComponent, {\n      xStart: xPosition,\n      xEnd: leftPosition.x,\n    }, {\n      yStart: yPosition + root.nodeCircle.getRadius(),\n      yEnd: childYPosition - root.left.nodeCircle.getRadius(),\n    });\n  }\n\n  // Draw the right child\n  if (root.right) {\n    const rightOfRight = spacingMap.get(root.right)!.right;\n    const childYPosition = yPosition + theme.lineHeight;\n    const rightPosition = {\n      x: xPosition + getXPositionFromGivenHorizontalNodePosition(\n          right - rightOfRight,\n      ),\n      y: childYPosition,\n    };\n\n    requiredRedraw = recursivelyDrawNodes(\n        root.right,\n        canvasComponent,\n        rightPosition,\n        highlightMode,\n    ) || requiredRedraw;\n    connectPointsWithBezierCurve(canvasComponent, {\n      xStart: xPosition,\n      xEnd: rightPosition.x,\n    }, {\n      yStart: yPosition + root.nodeCircle.getRadius(),\n      yEnd: childYPosition - root.right.nodeCircle.getRadius(),\n    });\n  }\n\n  return requiredRedraw;\n}\n\n/**\n * Calculates the spacing required recursively\n *\n * @param {BinaryTreeNode<string | number>} root\n * @return {number} - The spacing requirement of that node\n */\nfunction calculateSpacingMapRecursively(\n    root: BinaryTreeNode<string | number>,\n): number {\n  const left = root.left ? calculateSpacingMapRecursively(\n      root.left,\n  ) + 0.5: 0;\n  const right = root.right ? calculateSpacingMapRecursively(\n      root.right,\n  ) + 0.5: 0;\n  spacingMap.set(root, {\n    left,\n    right,\n  });\n\n  return left + right;\n}\n\n/**\n * Draw a pretty binary tree\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} canvasComponent\n * @param {IndividualInputOptions} options\n */\nfunction drawPrettyBinaryTree(\n    root: BinaryTreeNode<string | number>,\n    canvasComponent: CanvasComponent,\n    options: IndividualInputOptions,\n) {\n  spacingMap = new Map();\n  const maxNodeSpacing = calculateSpacingMapRecursively(root);\n  const heightOfTree = root.getHeight();\n  const {maxHeight, maxWidth, highlightMode} = options;\n\n  // Calculate canvas spacing requirements\n  const {\n    maxCanvasWidthRequired,\n    actualMaxHeight,\n    actualMaxWidth,\n  } = getRequiredAndActualHeightAndWidth(\n      maxNodeSpacing,\n      heightOfTree,\n      maxWidth,\n      maxHeight,\n  );\n\n  // Init calculation\n  const left = spacingMap.get(root)!.left;\n  const midPointInCanvas = actualMaxWidth / 2;\n  const xStart = (midPointInCanvas - maxCanvasWidthRequired / 2);\n\n  // Initialize the canvas\n  canvasComponent.setMaxWidthAndHeight(actualMaxHeight, actualMaxWidth);\n\n  /**\n   * Hover event handler\n   */\n  canvasComponent.onHover((color) => {\n    hoveredColorId = color;\n    requestAnimationFrame(root, canvasComponent, {\n      x: xStart + getXPositionFromGivenHorizontalNodePosition(left+1),\n      y: getCanvasHeightFromTreeHeight(0.5),\n    }, Boolean(highlightMode));\n  });\n\n  // Recursively draw all nodes\n  requestAnimationFrame(root, canvasComponent, {\n    x: xStart + getXPositionFromGivenHorizontalNodePosition(left+1),\n    y: getCanvasHeightFromTreeHeight(0.5),\n  }, Boolean(highlightMode));\n}\n\nexport default drawPrettyBinaryTree;\n","import CanvasComponent from './Canvas';\nimport theme from '../config/theme';\nimport BinaryTreeNode from '../tree/BinaryTreeNode';\nimport {Point} from '../types/Point';\nimport {\n  getCanvasHeightFromTreeHeight,\n  getCanvasWidthFromMaxNodeSpacing,\n  getXPositionFromGivenHorizontalNodePosition,\n} from '../utils/tree';\nimport {IndividualInputOptions, PathArray} from './types';\nimport connectPointsWithBezierCurve\n  from '../utils/connectPointsWithBezierCurve';\n\n/**\n * The current animation frame that is going on\n */\nlet animationFrameId: number;\n\n/**\n * Array of all children that needs printing\n */\nlet globalPathArray: PathArray;\n\n/**\n * Current color that is being hovered on\n */\nlet hoveredColorId: string;\n\n/**\n * Map storing the colorId to the path array\n */\nlet colorIdToPathMap: Map<string, PathArray> = new Map();\n\n/**\n * Clear the existing animation frame if any and request an animation frame\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} comp\n * @param {IndividualInputOptions} options\n */\nfunction requestAnimationFrame(\n    root: BinaryTreeNode<string | number>,\n    comp: CanvasComponent,\n    options: IndividualInputOptions,\n) {\n  // Clear existing animation frame\n  if (animationFrameId) {\n    cancelAnimationFrame(animationFrameId);\n  }\n\n  // Request a new one\n  animationFrameId = window.requestAnimationFrame(\n      () => animationFrameCB(root, comp, options),\n  );\n}\n\n\n/**\n * Get the node height from print array\n *\n * @return {number}\n */\nfunction getNodeHeightFromGlobalPathArray() {\n  return globalPathArray.length + 1;\n}\n\n\n/**\n * Get the node width from the print array\n *\n * @return {{\n *  left: number,\n *  right: number\n * }}\n */\nfunction getNodeWidthFromGlobalPathArray() {\n  let left = 0;\n  let right = 0;\n  let current = 0;\n\n  for (const childDirection of globalPathArray) {\n    if (childDirection === 'left') {\n      current -= 1;\n    } else {\n      current += 1;\n    }\n    if (current < 0) {\n      left = Math.max(Math.abs(current), left);\n    } else {\n      right = Math.max(current, right);\n    }\n  }\n\n  return {\n    left, right,\n  };\n}\n\n/**\n * Draw single node\n *\n * @param {BinaryTreeNode} node\n * @param {CanvasComponent} comp\n * @param {PathArray} pathArray\n * @param {Point} position\n * @return {boolean} Weather redraw is required\n */\nfunction drawSingleNode(\n    node: BinaryTreeNode<string | number>,\n    comp: CanvasComponent,\n    pathArray: PathArray,\n    position: Point,\n) {\n  const {x, y} = position;\n  const doesNodeHaveChildren = Boolean(node.left || node.right);\n  node.nodeCircle.setCoordinates(x, y);\n\n  // Grow or shrink while hover\n  const colorId = node.nodeCircle.draw(comp);\n  colorIdToPathMap.set(colorId, pathArray);\n  if (colorId === hoveredColorId && doesNodeHaveChildren) {\n    return node.nodeCircle.grow();\n  } else {\n    return node.nodeCircle.restoreCircle();\n  }\n}\n\n/**\n * Draw both the children if required\n *\n * @param {BinaryTreeNode} node\n * @param {CanvasComponent} comp\n * @param {number} xPosition\n * @param {number} nodeHeight\n * @param {PathArray} pathArray\n * @return {boolean}\n */\nfunction drawChildren(\n    node: BinaryTreeNode<string | number>,\n    comp: CanvasComponent,\n    xPosition: number,\n    nodeHeight: number,\n    pathArray: PathArray,\n) {\n  const currentHeight = getCanvasHeightFromTreeHeight(nodeHeight);\n  const childHeight = getCanvasHeightFromTreeHeight(nodeHeight + 1);\n  let requiredRedraw = false;\n\n  // Draw the left child\n  if (node.left) {\n    const currentPathArray : PathArray = node.left.left || node.left.right ?\n      [...pathArray, 'left'] : [...pathArray];\n    const xLeft = xPosition - (0.5 * theme.leafNodeSpace);\n\n    requiredRedraw = drawSingleNode(\n        node.left,\n        comp,\n        currentPathArray, {\n          x: xLeft,\n          y: childHeight,\n        },\n    ) || requiredRedraw;\n    connectPointsWithBezierCurve(comp, {\n      xStart: xPosition,\n      xEnd: xLeft,\n    }, {\n      yStart: currentHeight + node.nodeCircle.getRadius(),\n      yEnd: childHeight - node.left.nodeCircle.getRadius(),\n    });\n  }\n\n  // Draw the right child\n  if (node.right) {\n    const currentPathArray : PathArray = node.right.left || node.right.right ?\n      [...pathArray, 'right'] : [...pathArray];\n    const xRight = xPosition + (0.5 * theme.leafNodeSpace);\n\n    requiredRedraw = drawSingleNode(\n        node.right,\n        comp,\n        currentPathArray, {\n          x: xRight,\n          y: childHeight,\n        },\n    ) || requiredRedraw;\n    connectPointsWithBezierCurve(comp, {\n      xStart: xPosition,\n      xEnd: xRight,\n    }, {\n      yStart: currentHeight + node.nodeCircle.getRadius(),\n      yEnd: childHeight - node.right.nodeCircle.getRadius(),\n    });\n  }\n\n  return requiredRedraw;\n}\n\n\n/**\n * Draw all the nodes by following print array\n *\n * @param {BinaryTreeNode} root\n * @param {CanvasComponent} comp\n * @param {number} xRootPosition\n * @return {boolean} - Weather animated redraw is required\n */\nfunction drawAllNodes(\n    root:BinaryTreeNode<string | number>,\n    comp: CanvasComponent,\n    xRootPosition: number): boolean {\n  // Draw root\n  let currentNode = root;\n  let xPosition = xRootPosition;\n  let currentNodeHeight = 0.5;\n  const currentPathArray: Array<'left' | 'right'> = [];\n  let requiredRedraw = drawSingleNode(root, comp, [...currentPathArray], {\n    x: xPosition,\n    y: getCanvasHeightFromTreeHeight(currentNodeHeight),\n  });\n\n  // Draw all the children according to the path\n  for (const currentPath of globalPathArray) {\n    requiredRedraw = drawChildren(\n        currentNode,\n        comp,\n        xPosition,\n        currentNodeHeight,\n        currentPathArray,\n    ) || requiredRedraw;\n\n    if (currentPath === 'left') {\n      currentNode = currentNode.left!;\n      xPosition = xPosition - (0.5 * theme.leafNodeSpace);\n      currentPathArray.push('left');\n    } else {\n      currentNode = currentNode.right!;\n      xPosition = xPosition + (0.5 * theme.leafNodeSpace);\n      currentPathArray.push('right');\n    }\n    currentNodeHeight += 1;\n  }\n\n  // Draw the children of the last element in the path\n  requiredRedraw = drawChildren(\n      currentNode,\n      comp,\n      xPosition,\n      currentNodeHeight,\n      currentPathArray,\n  ) || requiredRedraw;\n\n  // Return if redraw is required\n  return requiredRedraw;\n}\n\n/**\n * Animation frame call back function that will recursively be called.\n * In case animation is required\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} comp\n * @param {IndividualInputOptions} options\n */\nfunction animationFrameCB(\n    root: BinaryTreeNode<string | number>,\n    comp: CanvasComponent,\n    options: IndividualInputOptions,\n) {\n  // Height and width calculations\n  const nodeHeight = getNodeHeightFromGlobalPathArray();\n  const {\n    left: leftNodeWidth,\n    right: rightNodeWidth,\n  } = getNodeWidthFromGlobalPathArray();\n  const requiredHeight = getCanvasHeightFromTreeHeight(nodeHeight + 1);\n  const requiredWidth = getCanvasWidthFromMaxNodeSpacing(\n      leftNodeWidth+rightNodeWidth,\n  );\n  const actualHeight = Math.max(requiredHeight, options.maxHeight);\n  const actualWidth = Math.max(requiredWidth, options.maxWidth);\n  const xStart = (actualWidth/2) - (requiredWidth/2);\n\n  // Set the height and width\n  // This also clears the canvas. So no need to clear it manually.\n  comp.setMaxWidthAndHeight(actualHeight, actualWidth);\n\n  // Initialize color id to path map\n  colorIdToPathMap = new Map();\n\n  // Draw and check if redraw is required\n  const requiredRedraw = drawAllNodes(\n      root,\n      comp,\n      xStart + getXPositionFromGivenHorizontalNodePosition(leftNodeWidth + 1),\n  );\n  if (requiredRedraw) {\n    requestAnimationFrame(root, comp, options);\n  }\n}\n\n/**\n * Draw an expandable binary tree\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} canvasComponent\n * @param {IndividualInputOptions} options\n */\nfunction drawExpandableBinaryTree(\n    root: BinaryTreeNode<string | number>,\n    canvasComponent: CanvasComponent,\n    options: IndividualInputOptions,\n) {\n  // Initialization\n  globalPathArray = [];\n\n  /**\n   * Click event handler\n   */\n  canvasComponent.onClick((color) => {\n    globalPathArray = colorIdToPathMap.get(color) || globalPathArray;\n    requestAnimationFrame(root, canvasComponent, options);\n  });\n\n  /**\n   * Hover event handler\n   */\n  canvasComponent.onHover((color) => {\n    hoveredColorId = color;\n    requestAnimationFrame(root, canvasComponent, options);\n  });\n\n  // Draw frame\n  requestAnimationFrame(root, canvasComponent, options);\n}\n\nexport default drawExpandableBinaryTree;\n","import CanvasComponent from './Canvas';\nimport BinaryTreeNode from '../tree/BinaryTreeNode';\nimport theme from '../config/theme';\nimport {\n  getCanvasHeightFromTreeHeight,\n  getMaxLeafNodesFromHeight,\n  getRequiredAndActualHeightAndWidth,\n} from '../utils/tree';\nimport {\n  HorizontalStartAndEndInput,\n  IndividualInputOptions,\n} from './types';\nimport connectPointsWithBezierCurve\n  from '../utils/connectPointsWithBezierCurve';\n\n/**\n * Recursively draw all the nodes\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} canvasComponent\n * @param {number} currentLine\n * @param {HorizontalStartAndEndInput} horizontalConfig\n */\nfunction recursivelyDrawNodes(\n    root: BinaryTreeNode<string | number>,\n    canvasComponent: CanvasComponent,\n    currentLine: number,\n    horizontalConfig: HorizontalStartAndEndInput,\n) {\n  // X Calculation\n  const {xStart, xEnd} = horizontalConfig;\n  const xPosition = (xStart + xEnd) / 2;\n\n  // Y Calculation\n  const yPosition = currentLine * theme.lineHeight;\n\n  // Draw the node\n  root.nodeCircle.setCoordinates(xPosition, yPosition);\n  root.nodeCircle.draw(canvasComponent);\n\n\n  // Draw the left child nodes\n  // Radius is added and subtracted from y to move the line outside the circle\n  if (root.left) {\n    recursivelyDrawNodes(root.left, canvasComponent, currentLine+1, {\n      xStart,\n      xEnd: xPosition,\n    });\n    connectPointsWithBezierCurve(canvasComponent, {\n      xStart: xPosition,\n      xEnd: (xStart + xPosition) / 2,\n    }, {\n      yStart: yPosition + theme.radius,\n      yEnd: getCanvasHeightFromTreeHeight(currentLine + 1) - theme.radius,\n    });\n  }\n\n  if (root.right) {\n    recursivelyDrawNodes(root.right, canvasComponent, currentLine+1, {\n      xStart: xPosition,\n      xEnd,\n    });\n    connectPointsWithBezierCurve(canvasComponent, {\n      xStart: xPosition,\n      xEnd: (xPosition + xEnd) / 2,\n    }, {\n      yStart: yPosition + theme.radius,\n      yEnd: getCanvasHeightFromTreeHeight(currentLine + 1) - theme.radius,\n    });\n  }\n}\n\n/**\n * Draw an expandable binary tree\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} canvasComponent\n * @param {IndividualInputOptions} options\n */\nfunction drawSimpleBinaryTree(\n    root: BinaryTreeNode<string | number>,\n    canvasComponent: CanvasComponent,\n    options: IndividualInputOptions,\n) {\n  const heightOfTree = root.getHeight();\n  const maxNumberOfLeafNodes = getMaxLeafNodesFromHeight(heightOfTree);\n  const {maxHeight, maxWidth} = options;\n\n  // Max height and width requirements\n  const {\n    maxCanvasWidthRequired,\n    actualMaxHeight,\n    actualMaxWidth,\n  } = getRequiredAndActualHeightAndWidth(\n      maxNumberOfLeafNodes,\n      heightOfTree,\n      maxWidth,\n      maxHeight,\n  );\n\n  // Init calculation\n  const midPointInCanvas = actualMaxWidth / 2;\n  const xStart = (midPointInCanvas - maxCanvasWidthRequired / 2) +\n  theme.leafNodeSpace;\n  const xEnd = (midPointInCanvas + maxCanvasWidthRequired / 2) -\n  theme.leafNodeSpace;\n\n  // Initialize the canvas\n  canvasComponent.setMaxWidthAndHeight(actualMaxHeight, actualMaxWidth);\n\n  // Recursively draw the tree\n  recursivelyDrawNodes(root, canvasComponent, 0.5, {xStart, xEnd});\n}\n\nexport default drawSimpleBinaryTree;\n","import BinaryTreeNode from '../tree/BinaryTreeNode';\nimport {VisualizationType} from '../enumns/VisualizationType';\nimport drawPrettyBinaryTree from './drawPrettyBinaryTree';\nimport drawExpandableBinaryTree from './drawExpandableBinaryTree';\nimport drawSimpleBinaryTree from './drawSimpleBinaryTree';\nimport {MainInputOptions} from './types';\nimport CanvasComponent from './Canvas';\n\n// For keeping track of canvas components for canvas elements\nconst canvasMap: Map<HTMLCanvasElement, CanvasComponent> = new Map();\n\n/**\n * Draw a binary tree in one of the given types\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {HTMLCanvasElement} canvasElement\n * @param {Partial<MainInputOptions>} options\n */\nfunction drawBinaryTree(\n    root: BinaryTreeNode<string | number>,\n    canvasElement: HTMLCanvasElement,\n    options: Partial<MainInputOptions> = {},\n) {\n  const {\n    type = VisualizationType.SIMPLE,\n    maxHeight = window.innerHeight,\n    maxWidth = window.innerWidth,\n  } = options;\n\n  const canvasComponent = canvasMap.get(canvasElement) ||\n  new CanvasComponent(canvasElement);\n  canvasMap.set(canvasElement, canvasComponent);\n\n  switch (type) {\n    case VisualizationType.PRETTY:\n      drawPrettyBinaryTree(root, canvasComponent, {\n        maxHeight,\n        maxWidth,\n      });\n      break;\n\n    case VisualizationType.EXPANDABLE:\n      drawExpandableBinaryTree(root, canvasComponent, {\n        maxHeight,\n        maxWidth,\n      });\n      break;\n\n    case VisualizationType.HIGHLIGHT:\n      drawPrettyBinaryTree(root, canvasComponent, {\n        maxHeight,\n        maxWidth,\n        highlightMode: true,\n      });\n      break;\n\n    default:\n      drawSimpleBinaryTree(root, canvasComponent, {\n        maxHeight,\n        maxWidth,\n      });\n      break;\n  }\n}\n\nexport default drawBinaryTree;\n","import CanvasComponent from './Canvas';\nimport drawBinaryTree from './drawBinaryTree';\n\nexport {\n  CanvasComponent,\n  drawBinaryTree,\n};\n","export * from './VisualizationType';\n","export * from './theme';\n","import {\n  BinarySearchTreeNode,\n  drawBinaryTree,\n  VisualizationType,\n  setTheme\n} from \"binary-tree-visualizer\";\n\nsetTheme({\n  radius: 30,\n  fontSize: 12\n});\n\nconst root = new BinarySearchTreeNode<number>(100);\n[50, 145, 150, 130, 120, 140, 30, 70, 75, 80, 35].forEach((num) =>\n  root.insert(num)\n);\n\ndrawBinaryTree(root, document.querySelector(\"canvas\")!, {\n  type: VisualizationType.HIGHLIGHT\n});\n","import {\n  BinarySearchTreeNode,\n  drawBinaryTree,\n  VisualizationType,\n  setTheme\n} from \"binary-tree-visualizer\";\n\nsetTheme({\n  radius: 30,\n  fontSize: 12\n});\n\nconst root = new BinarySearchTreeNode<number>(100);\n[50, 145, 150, 130, 120, 140, 30, 70, 75, 80, 35].forEach((num) =>\n  root.insert(num)\n);\n\ndrawBinaryTree(root, document.querySelector(\"canvas\")!, {\n  type: VisualizationType.HIGHLIGHT\n});\n"]}